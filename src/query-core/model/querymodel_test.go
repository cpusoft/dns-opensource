package model

import (
	"fmt"
	"testing"

	"dns-model/common"
	"github.com/cpusoft/goutil/belogs"
	"github.com/cpusoft/goutil/convert"
	"github.com/cpusoft/goutil/jsonutil"
)

// dig  @127.0.0.1 -p 8125 +noadflag +nodnssec +noedns  +norecurse example.com
// host -t A www.baidu.com
// tcpdump -nt -s 500 -x port domain
func TestQuestion(t *testing.T) {
	receiveBytes := []byte{
		0x2f, 0x10, 0x01, 0x00, 0x00, 0x01,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x02, 0x68, 0x35, 0x05, 0x71, 0x7a,
		0x6f, 0x6e, 0x65, 0x02, 0x71, 0x71,
		0x03, 0x63, 0x6f, 0x6d, 0x00, 0x00, 0x01, 0x00, 0x01,
	}
	headerType, headerModel, err := common.ParseBytesToHeaderModel(receiveBytes[:common.DNS_HEADER_LENGTH])
	if err != nil {
		belogs.Error("TestQuestion(): ParseBytesToHeaderModel fail:", convert.PrintBytesOneLine(receiveBytes[:common.DNS_HEADER_LENGTH]))
		return
	}
	offsetFromStart := uint16(common.DNS_HEADER_LENGTH)
	belogs.Debug("TestQuestion(): headerType:", headerType, "   headerModel:", jsonutil.MarshalJson(headerModel), "  offsetFromStart:", offsetFromStart)

	// count
	countModel, err := common.ParseBytesToCountModel(receiveBytes[offsetFromStart:offsetFromStart+common.DNS_COUNT_LENGTH], headerType)
	if err != nil {
		belogs.Error("TestQuestion(): ParseBytesToCountModel fail:", convert.PrintBytesOneLine(receiveBytes[offsetFromStart:offsetFromStart+common.DNS_COUNT_LENGTH]))
		return
	}
	offsetFromStart += uint16(common.DNS_COUNT_LENGTH)
	belogs.Debug("TestQuestion(): headerType:", headerType, "   countModel:", jsonutil.MarshalJson(countModel), "  offsetFromStart:", offsetFromStart)

	ms, nl, err := ParseBytesToQueryModel(headerModel, countModel, receiveBytes[offsetFromStart:], offsetFromStart)
	fmt.Println(jsonutil.MarshalJson(ms), nl, err)
}
func TestAnswer(t *testing.T) {
	receiveBytes := []byte{
		0x2f, 0x10, 0x81, 0x80, 0x00, 0x01, 0x00, 0x01, 0x00, 0x04, 0x00, 0x11, 0x02, 0x68, 0x35, 0x05,
		0x71, 0x7a, 0x6f, 0x6e, 0x65, 0x02, 0x71, 0x71, 0x03, 0x63, 0x6f, 0x6d, 0x00, 0x00, 0x01, 0x00,
		0x01, 0xc0, 0x0c, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x01, 0xf2, 0x00, 0x04, 0x0e, 0x12, 0xb4,
		0x71, 0xc0, 0x0f, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x0e, 0xc0, 0x00, 0x0a, 0x07, 0x6e, 0x73,
		0x2d, 0x63, 0x6e, 0x63, 0x31, 0xc0, 0x15, 0xc0, 0x0f, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x0e,
		0xc0, 0x00, 0x0a, 0x07, 0x6e, 0x73, 0x2d, 0x63, 0x6d, 0x6e, 0x31, 0xc0, 0x15, 0xc0, 0x0f, 0x00,
		0x02, 0x00, 0x01, 0x00, 0x00, 0x0e, 0xc0, 0x00, 0x0a, 0x07, 0x6e, 0x73, 0x2d, 0x74, 0x65, 0x6c,
		0x31, 0xc0, 0x15, 0xc0, 0x0f, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x0e, 0xc0, 0x00, 0x09, 0x06,
		0x6e, 0x73, 0x2d, 0x6f, 0x73, 0x31, 0xc0, 0x15, 0xc0, 0x7f, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00,
		0x01, 0xfd, 0x00, 0x04, 0xcb, 0xcd, 0xdc, 0x1a, 0xc0, 0x7f, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00,
		0x01, 0xfd, 0x00, 0x04, 0xcb, 0xcd, 0xec, 0xc6, 0xc0, 0x7f, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00,
		0x01, 0xfd, 0x00, 0x04, 0xcb, 0xcd, 0xc3, 0x35, 0xc0, 0x7f, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00,
		0x01, 0xfd, 0x00, 0x04, 0xcb, 0xcd, 0xc3, 0x4b, 0xc0, 0x7f, 0x00, 0x1c, 0x00, 0x01, 0x00, 0x00,
		0x01, 0xfd, 0x00, 0x10, 0x24, 0x02, 0x4e, 0x00, 0x80, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x22, 0xc0, 0x53, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x0b, 0x16, 0x00, 0x04,
		0x79, 0x33, 0x5e, 0xb5, 0xc0, 0x53, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x0b, 0x16, 0x00, 0x04,
		0x79, 0x33, 0xa0, 0xcf, 0xc0, 0x53, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x0b, 0x16, 0x00, 0x04,
		0xb6, 0xfe, 0x34, 0x37, 0xc0, 0x53, 0x00, 0x1c, 0x00, 0x01, 0x00, 0x00, 0x01, 0xfd, 0x00, 0x10,
		0x24, 0x02, 0x4e, 0x00, 0x80, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22,
		0xc0, 0x3d, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x01, 0xfd, 0x00, 0x04, 0x3a, 0xfb, 0x67, 0x6d,
		0xc0, 0x3d, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x01, 0xfd, 0x00, 0x04, 0x74, 0x80, 0x99, 0x14,
		0xc0, 0x3d, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x01, 0xfd, 0x00, 0x04, 0x6f, 0xa1, 0x6b, 0xc3,
		0xc0, 0x3d, 0x00, 0x1c, 0x00, 0x01, 0x00, 0x00, 0x01, 0xfd, 0x00, 0x10, 0x24, 0x02, 0x4e, 0x00,
		0x80, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xc0, 0x69, 0x00, 0x01,
		0x00, 0x01, 0x00, 0x00, 0x0b, 0x16, 0x00, 0x04, 0x65, 0x5b, 0x5e, 0x33, 0xc0, 0x69, 0x00, 0x01,
		0x00, 0x01, 0x00, 0x00, 0x0b, 0x16, 0x00, 0x04, 0x7b, 0x97, 0x42, 0x53, 0xc0, 0x69, 0x00, 0x01,
		0x00, 0x01, 0x00, 0x00, 0x0b, 0x16, 0x00, 0x04, 0x3a, 0x3c, 0x0a, 0x64, 0xc0, 0x69, 0x00, 0x1c,
		0x00, 0x01, 0x00, 0x00, 0x01, 0xfd, 0x00, 0x10, 0x24, 0x02, 0x4e, 0x00, 0x80, 0x30, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03}

	headerType, headerModel, err := common.ParseBytesToHeaderModel(receiveBytes[:common.DNS_HEADER_LENGTH])
	if err != nil {
		belogs.Error("TestAnswer(): ParseBytesToHeaderModel fail:", convert.PrintBytesOneLine(receiveBytes[:common.DNS_HEADER_LENGTH]))
		return
	}
	offsetFromStart := uint16(common.DNS_HEADER_LENGTH)
	belogs.Debug("TestAnswer(): headerType:", headerType, "   headerModel:", jsonutil.MarshalJson(headerModel), "  offsetFromStart:", offsetFromStart)

	// count
	countModel, err := common.ParseBytesToCountModel(receiveBytes[offsetFromStart:offsetFromStart+common.DNS_COUNT_LENGTH], headerType)
	if err != nil {
		belogs.Error("TestAnswer(): ParseBytesToCountModel fail:", convert.PrintBytesOneLine(receiveBytes[offsetFromStart:offsetFromStart+common.DNS_COUNT_LENGTH]))
		return
	}
	offsetFromStart += uint16(common.DNS_COUNT_LENGTH)
	belogs.Debug("TestAnswer(): headerType:", headerType, "   countModel:", jsonutil.MarshalJson(countModel), "  offsetFromStart:", offsetFromStart)

	ms, nl, err := ParseBytesToQueryModel(headerModel, countModel, receiveBytes[offsetFromStart:], offsetFromStart)
	fmt.Println(jsonutil.MarshalJson(ms), nl, err)
}
